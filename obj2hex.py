#!/usr/bin/env python3

"""
Converts a Brandon LC-3 object file generated by as2obj to hex you can
load into a Roigisim ROM/RAM or paste into a Roigism JSON file.

This hack brought to you by Austin Adams, New Year's Eve 2017.
"""

import sys
from collections import namedtuple
from argparse import ArgumentParser

ObjectFileSegment = namedtuple('ObjectFileSegment', ('start', 'contents'))


class ObjectFile:
    """Parse a Brandon LC-3 object file"""

    # This is an LC-3 object file, so each word is 2 bytes
    WORD_SIZE = 2

    def __init__(self, objfile):
        self._segments = []

        self.parse(objfile)

    def parse(self, objfile):
        """Parse segments from `fp' until EOF."""

        while True:
            buf = objfile.read(self.WORD_SIZE)

            # EOF
            if not buf:
                break
            elif len(buf) != self.WORD_SIZE:
                raise ValueError('start address is only one byte!')

            start_addr = int.from_bytes(buf, byteorder='big')

            buf = objfile.read(self.WORD_SIZE)
            if len(buf) != self.WORD_SIZE:
                raise ValueError('short read for segment length')

            length = int.from_bytes(buf, byteorder='big')

            buf = objfile.read(length * self.WORD_SIZE)
            if len(buf) != length * self.WORD_SIZE:
                raise ValueError('short read for segment body')

            self._segments.append(ObjectFileSegment(start_addr, buf))

    def segments(self):
        """
        Return list of ObjectFileSegment instances which represent the
        segments in this object file.
        """

        return self._segments


class Hexdump:
    """
    Base class for generating ascii hexdumps from a list of object file
    segments.
    """

    def __init__(self, segments, word_size, sep=' '):
        self.words = []
        self.word_size = word_size
        self.sep = sep

        self.from_segments(segments)

    def __str__(self):
        return self.sep.join(self.words)

    def pad(self, num_words):
        """
        Add num_words zero words at the end of the current wordlist.
        Useful for separating object file segments.
        """
        self.words += ['00' * self.word_size] * num_words

    def from_segments(self, segments):
        """Populate the wordlist using the object file segments provided."""
        current_addr = 0

        for segment in sorted(segments, key=lambda seg: seg.start):
            if segment.start > current_addr:
                # Need to fill in this much space
                self.pad(segment.start - current_addr)
                current_addr = segment.start

            for i in range(0, len(segment.contents), self.word_size):
                word = segment.contents[i:i + self.word_size]
                self.words.append(word.hex())

            current_addr += len(segment.contents) // self.word_size

        # For the load/store button format and just for good vibes with
        # the JSON format, zero out remaining space.
        num_addresses = 2**(8 * self.word_size)
        if num_addresses > current_addr:
            self.pad(num_addresses - current_addr)

    @staticmethod
    def file_extension():
        """Conventional file extension of this hexdump format"""
        return 'dat'


class FancyHexdump(Hexdump):
    """Print a hexdump with rows and columns and stuff."""

    def __init__(self, segments, word_size):
        super().__init__(segments, word_size)

    def __str__(self):
        cols = 8 * self.word_size
        dump = ''
        i = 0

        while i < len(self.words):
            row_size = min(cols, len(self.words))
            dump += ' '.join(self.words[i:i + row_size])
            dump += '\n'
            i += row_size

        return dump


class RoiHexdump(Hexdump):
    """
    Generate a Roigisim-friendly hexdump from a list of object file
    segments. Supports JSON abbreviated format or the row/column format
    supported by the load/save buttons in the edit ROM/RAM window.
    """

    def __init__(self, segments, word_size):
        super().__init__(segments, word_size, sep=' ')

    def pad(self, num_words):
        """This is a Roi hexdump, so use the abbreviated format"""

        self.words.append('{}-{}'.format(num_words, '00' * self.word_size))


class VerilogHexdump(Hexdump):
    """Print verbosely, and one word per line"""

    def __init__(self, segments, word_size):
        super().__init__(segments, word_size, sep='\n')

    @staticmethod
    def file_extension():
        return 'list'


class ObfuscatedAsmHexdump(Hexdump):
    """Print verbosely, and one word per line"""

    def __init__(self, segments, word_size):
        super().__init__(segments, word_size, sep='\n')

    @staticmethod
    def file_extension():
        return 'hex.asm'

    def __str__(self):
        """Put .fills before each line"""
        return self.sep.join('.fill x' + word for word in self.words)

    def pad(self, num_words):
        """Don't pad."""
        pass


def main(argv):
    """
    Accept a path to an LC-3 object file on the command line and convert
    it to Roi hex.
    """

    parser = ArgumentParser(prog=argv[0],
                            description='Convert Brandon LC-3 object files to '
                                        'hex ready for Roigisim RAMs/ROMs.')
    parser.add_argument('objfile', help='Path to a Brandon object file '
                                        'generated by as2obj')
    parser.add_argument('datfile', nargs='?', default=None,
                        help="Path to which to write generated hex file. `-' "
                             "means stdout. Default: X.dat for an objfile of "
                             "X.obj")
    output = parser.add_mutually_exclusive_group(required=True)
    output.add_argument('--fancy', '-f', action='store_true',
                        help="Generate full (gigantic) hexdump instead of "
                             "using Roi's JSON abbreviation syntax")
    output.add_argument('--roi', '-r', action='store_true',
                        help="Use Roi's JSON abbreviation syntax in the "
                             "hexdump")
    output.add_argument('--verilog', '-v', action='store_true',
                        help="Generate verilog-style hexdump")
    output.add_argument('--obfuscate', '-O', action='store_true',
                        help="Generate obfuscated assembly")
    args = parser.parse_args(argv[1:])

    with open(args.objfile, 'rb') as objfile:
        obj = ObjectFile(objfile)

    hexdump_args = [obj.segments(), obj.WORD_SIZE]
    if args.fancy:
        hexdump = FancyHexdump(*hexdump_args)
    elif args.roi:
        hexdump = RoiHexdump(*hexdump_args)
    elif args.verilog:
        hexdump = VerilogHexdump(*hexdump_args)
    elif args.obfuscate:
        hexdump = ObfuscatedAsmHexdump(*hexdump_args)
    else:
        raise NotImplementedError('you added a new output type without '
                                  'calling it in main(), good job')

    if args.datfile == '-':
        sys.stdout.write(str(hexdump))
    else:
        if args.datfile is not None:
            hexpath = args.datfile
        else:
            hexpath = '{}.{}'.format(args.objfile.rsplit('.', maxsplit=1)[0],
                                     hexdump.file_extension())

        with open(hexpath, 'w') as hexfile:
            hexfile.write(str(hexdump))

    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv))
